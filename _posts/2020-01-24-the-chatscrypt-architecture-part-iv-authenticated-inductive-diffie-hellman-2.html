---
layout: post
title: "The ChatScrypt Architecture Part IV: Authenticated Inductive Diffie-Hellman 2.0"
comments: true
date: 2020-01-24
---

I decided to carefully write out my third and hopefully final attempt at the protocol I will be using for ChatScrypt, the AIDH protocol with a bounded number of keys. This will be slightly different from how I ended the previous post, in that Alice will ask for permission to update her own keys, not Bob's. This is more efficient: It will always succeed as Alice is the one controlling her own key generation, since she can be patient (in contrast, in the previous post, Bob might be chatting away, generating more and more keys; he can't save them all waiting for Alice's requests, and so sometimes may need to deny if she's too slow). 

<p>As I hinted at earlier, this is actually quite similar to the Signal protocol: There is some "back and forth" ratchet going on. On the other hand it is quite different, simplifying the E3DH significantly, and removing KDF chains entirely from the Double Ratchet.

<p>I will omit writing literal public keys <b>g^x mod N</b>, writing just "public key <b>x</b>" instead.


<h2>Alice's state</h2>

<p>Once the protocol is initiated, Alice will have the following state variables:
<ul>
<li>The number of messages <b>M</b> she has sent, and a list of integers enumerating which of Bob's messages she has received. (The contiguous part stemming from 0 may be deleted.) The list should typically be length 1.
<li>Alice's current private key <b>x</b> and pending private key <b>x*</b>, waiting for approval from Bob.
<li>Bob's current public key <b>y</b> and previous public key <b>y'</b>, in case Alice has updated to <b>y</b>, but waits a bit to tell Bob.
<li>A binary indicating whether a new update request needs to be initiated at the next outgoing message; and a second binary indicating that Bob's update request has been approved. Call these the "Update" and "Approved" binaries, respectively.
<li>A binary that is either Active or Passive.
</ul>



<h2>Initialization</h2>
Bob publishes to the server a new signed public key <b>y</b>. He refreshes this key every time someone initiates a new correspondence with him. Alice publishes to the server an unsigned but long-term public key <b>a</b>.

<p>When Alice wants to initiate a correspondence with Bob, she fetches Bob's signed public key, verifies the signature, and sends some metadata to Bob using the shared Diffie-Hellman encryption key
<div class="media">
<b>g^(ay) mod N.</b>
</div>

Alice then initializes her state:
<ul>
<li>The number of messages she has sent so far is <b>M = 0</b>, and the list of integers of receipted messsages is empty.
<li>Both private keys are set to <b>a</b>.
<li>Both of Bob's public keys are set to <b>y</b>. 
<li>Active.
</ul>

<p>Bob is similarly initialized, with private keys set to <b>y</b> and public keys set to <b>a</b>.



<h2>Sending a message</h2>
Alice creates a new Diffie-Hellman key pair with private key <b>r</b> and then encrypts her message using the shared Diffie-Hellman encryption keys 
<div class="media">
<b>g^(xy) mod N</b> and <b>g^(ry) mod N</b>.
</div>

She attaches the following to her message:
<ul>
<li> (unencrypted) The public key <b>r</b>. 
<li> (encrypted) The message number <b>M + 1</b>, and the number of messages Bob has sent Alice (0 if not contiguous).
<li> (encrypted) The Active/Passive binary is included here.
</ul>


Lastly, she updates her state:
<ul>
<li>Increment <b>M = M + 1</b>. The integer list is unchanged.
<li>If Active, update <b>x* = r</b>.
<li>Both of Bob's public keys are unchanged.
<li>Set to Passive.
</ul>




<h2> Receiving a message</h2>

If Bob is Active, he decrypts the message using <b>x', y, r</b>. If he is passive, he uses <b>x, y, r</b>. He updates his state as follows if the message number and timestamp are sensible.

<ul>
<li>Bob's <b>M</b> is unchanged. The integer list is updated. If the list is contiguous from the beginning, Bob can empty the list. If either the list is not contiguous, or Alice's side is not contiguous, or Alice has received fewer messages than Bob has sent, a flag is raised.
<li>If the message binary is Active, update <b>y = y*</b>.
<li>If the message binary is Active, update <b>x' = x</b> and <b>x = r</b>.
<li>If the message binary is Active, Bob's state binary becomes Active.
</ul>

