---
layout: post
title: "Zero Knowledge Security: ChatScrypt Passwords"
comments: true
date: 2019-12-25
---

Or: Why you can (as of about December 23, 2019) feel free to use a real password when creating a ChatScrypt account (though there's nothing there right now once you do).

<p>Normally, when creating accounts with sketchy, unvalidated websites, you should offer a "fake" password, because chances are the web developers for that site are not securely storing the password you provide (not that you should be reusing passwords to begin with, but I assume you are only human).
  
 <p>The internet has a lot on the matter of password storage (google "store password database" or watch <a href="https://www.youtube.com/watch?v=8ZtInClXe1Q">this Computerphile video</a>, which is actually where I first learned about this business). Everyone who takes the time to write an article about this seems to make a big deal of it, as though it is extremely complicated, but I found that this is one of the simpler security matters out there (which perhaps is why it is a big deal: It's simple enough to allow average-to-mediocre software developers to handle on their own). I'll provide a quick overview:
   
<ul>
   <li> Passwords should always be "salted": Humans typically choose very poor passwords, and repeat them. Salting is where the software automatically appends random letters to the user-provided password to ensure the actual under-the-hood password is a "good" one. This protects against dictionary attacks.
     
   <li> Then, the salted password should be hashed, or essentially, encrypted while throwing away the key (more precisely, there never was a key). This is alright because the software doesn't actually need the password; it just needs to know whether someone knows the password. The deterministic nature of the destruction allows the software to check whether someone knows the password, by hashing a later claimed password and comparing with the original output. In any case: Only the hashed password should be stored in the database. This obviously protects users who reuse passwords in the case of a database breach, as password hashes are not readable.
</ul>

<h2>Server side or client side?</h2>

I did a lot of reading about password storage, and the above is all good and fine, but there was one particularly heated topic of debate on the internet: whether the salting and hashing should be performed by the client (on your laptop/phone, or more precisely, your browser) or the server (in a cloud somewhere). 

<p> The consensus seems to be that this must be done on the server side. There is a good reason for this: If the database is compromised, the stored hashed password is useless. Envision the authentication process: The server authentication software receives the <i>actual</i> password, and <i>then</i> salts and hashes it. A thief knowing only the hashed password cannot replicate this process.

<p>In contrast, if all the clever stuff above is done client-side, then the true user is indistinguishable from the thief: both present only a hashed password to the server.
  
<p>On the other hand, the internet seems to downplay the fact that the client has no way of knowing whether the server is performing the standard salt-hash safeguards (or even whether the server's developers are themselves trustworthy, which is evidently the case here). A client-side salt-hash guarantees a client-verifiable minimal level of protection, which is not even that bad. In the worst case, a user's ChatScrypt account may be compromised, but his/her other accounts are safe, even if they share passwords.
  
<p>I'm pleased to claim that ChatScrypt currently does <i>both</i>, client-side and server-side salting and hashing. I cannot prove this of the server, short of publicizing my Github/Heroku passwords, but you can actually check the client-side code (in Firefox, right click and view the source code). In particular, you can see that the plaintext password is salted and hashed via <a href="https://en.wikipedia.org/wiki/Bcrypt">bcrypt</a> and so I (the server) never see the users' plaintext passwords.
  
  <p>This is an instance of <i>zero-knowledge security</i> - the user's data cannot be compromised, because the software never receives it (in a readable form) to begin with.
    
<h2>An example</h2>

As I recommended above, the client salt-hash can be verified by a bit of exploration under the hood of your browser. But I thought it would be helpful to provide an example. Currently, a real account on ChatScrypt has username "alice" and password "password" (a typically awful password). But what's stored in my database instead of the password is

<div class="media">$2a$10$Qr6A5CUmH/JN1tdSj5y8EO 4SqQ5KQU/uSplUsmLF50raxBpGdNuIq</div>
  
<p> Meanwhile, I just created another account, with username "bob" and password "password". In my database, the password field contains

<div class="media">$2a$10$PpV4Er7YqpuKD8.JWZQFHu PJcApbr1QZkS2sm8C2FRx0n5GFbqzli</div>
  
  <p>In particular, though Alice and Bob have the same password, their salted hashes are entirely different (because of the salt). And of course, the hash makes the password unreadable, regardless of the salt.
    
    <p>(The "2a" in the hash is a header describing the bcrypt version in question, and the 10 is proportional to the number of iterations bcrypt performed.)
    
    
