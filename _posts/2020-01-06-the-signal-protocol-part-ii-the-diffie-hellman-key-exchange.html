---
layout: post
title: "The Signal Protocol Part II: The Diffieâ€“Hellman Key Exchange"
comments: true
date: 2020-01-06
---

Change of plan: Instead of discussing all of the primitives used by Signal, in this post I'll discuss the <i>Diffie-Hellman key exchange</i> in increasing levels of complexity, from the original formulation to the Signal protocol's "Extended Triple Diffie-Hellman."
<p>
<h2>The basic Diffie-Hellman key exchange</h2>

The Diffie-Hellman protocol is a means for two parties to securely agree on a shared encryption key, assuming there is a trustworthy public server (a bulletin board in clear view of the public, for instance). The shared encryption key may then be used to encrypt further communications.

<p> The idea is simple. The shared key will be 
<div class="media">
 <b>g^(ab) mod N,</b> 
</div>

where <b>g</b> and <b>N</b> needn't be secure (and in some ways are better if public), and <b>a</b> is a secret <i>private key</i> known only to Alice (and <b>b</b> likewise only to Bob). By the commutativity of multiplication, the shared secret may be computed as in any of the following three ways: 
<div class="media">
 <b>g^(ab) mod N = (g^a)^b mod N = (g^b)^a mod N.</b>
</div>
The point is that from <b>g^a mod N</b> (known as Alice's <i>public key</i>) it is difficult to retrieve Alice's private key <b>a</b>, so it can be (and is) shared freely. In particular, Bob can use it to compute the shared key. And by symmetry, Alice likewise.

<p>Some remarks on security properties.
 
<ul>
<li>I was discussing last time the trustworthiness of the server. If it is not trustworthy (eg. the bulletin board is not in public view), then sadly we are in a Matrix-like situation: The entity controlling the board can make Alice believe anything, including that she is talking to Bob, by simply manufacturing an identity and scrawling onto the bulletin board all the things Bob would (presumably hiding from Alice all the real messages Bob posts). The only guaranteed way around this is to take the red pill and contact Bob in real life. The above attack is known as a <i>man-in-the-middle</i> attack. It assumes the server is not just an eavesdropper but can tinker with messages.
 
<li> A (non-cryptographic) practice that combats man-in-the-middle attacks is to have keys with long lifetimes. This increases the likelihood that Alice will meet Bob in real life, chat about their (permanent or semi-permanent) public keys, and realize the Matrix's treachery. The Matrix cannot risk this, and so cannot forge Bob's public key with its own at the outset. This strategy comes at a cost: Bob's private key, if stolen, would compromise a larger proportion (if not all) of Bob's past messages, than if he rotated keys often. In short: Long term keys are more likely to be authentic but also more vulnerable if stolen. This latter property is known as a lack of <i>forward secrecy</i>.
 
<li> This protocol is <i>asynchronous</i>: Bob does not need to be present for Alice to compute the shared key that she would have with him, and thus can send an initial message to Bob at any time. 
</ul>

<p>The lack of provable protection against man-in-the-middle attacks is clearly unacceptable, but forward secrecy is also extremely desirable. Next, we augment Diffie-Hellman to obtain both.


<h2>Diffie-Hellman with authentication (the Station-to-Station protocol)</h2>

The <i>Station-to-Station</i> protocol is simply a way to combine long-term keys with short term keys to offer both authentication and forward secrecy. Simply use two keys (concatenate them, for instance):
<div class="media">
 <b>g^(ab) mod N</b> and <b>g^(xy) mod N</b>,
</div>
 where <b>x</b> is a private key generated by Alice specifically for one session of communication, and vice versa with private key <b>y</b> of Bob's.
 
Analysis:

<ul>
  <li>The following is slightly more secure, as it avoids the fact that <b>g^(ab) mod N</b> would be identical for every conversation:
<div class="media">
 <b>g^(ay) mod N,</b>  <b>g^(bx) mod N,</b> and <b>g^(xy) mod N</b>.
</div>
  The way to think about this perhaps is that to compute any of the three keys above, it is necessary and sufficient to know at least one variable in the exponent (eg. Alice knows, respectively, <b>a, x, x</b>).

 <li>Assuming long-term keys <b>a</b> and <b>b</b>, this has the improved authentication properties, discussed in the remarks of the previous section. Precisely: When Bob replies to Alice using all three of the above keys, and in particular the second one, she knows it must be Bob since no one has <b>x</b> (other than herself) and only Bob has <b>b</b>. In contrast, <b>y</b> is purportedly Bob's, but is new and has no historical connection with Bob; without insisting on using it alongside <b>b</b> (and all of its historical association with Bob), the server could very well have generated <b>y</b>, masquerading as Bob.
  
 <li>This has forward secrecy: a new <b>x</b> and <b>y</b> may be generated anew for each conversation, or indeed for each message.
  
 <li> However, both of these properties are only <i>synchronous</i>: <i>Until</i> Bob comes online and replies to Alice with the correct shared key encryption, Alice does not know that Bob was the one who made <b>y</b> (or rather, its public version <b>g^y mod N</b>); and of course Alice needs Bob to be online to generate new <b>y</b>'s to proceed with forward secrecy. 
</ul>
 
<p>In the last section, we discuss further augmentation to address the synchronization issues.



<h2>The Extended Triple Diffie-Hellman </h2>

The <i>Extended Triple Diffie-Hellman</i> (E3DH) is the actual initial key exchange protocol used by Signal. It addresses the two synchronization issues by augmenting the Station-to-Station protocol as follows.

<p> First, instead of just using one <b>x</b> or <b>y</b>, "many" are uploaded to the server ("posted on the bulletin"). They are used successively until they run out. These are called "one time keys" in the usual specification of the Signal protocol. I will say I am not a fan of this solution, though a true solution is essentially impossible. In fact, the technical specification for E3DH describes one time keys as "optional." 

<p> The matter of authenticating <b>y</b> without Bob's reply does have a true solution however, via a <i>Digital Signature Algorithm</i> (DSA). The trouble with the Diffie-Hellman based authentication described above was that for Bob to prove that he knows <b>b</b> (and thus is Bob), he needed (the public version of) Alice's <b>x</b>. In other words, Bob needed to have been online at some point after Alice created <b>x</b>. (Also note that <b>y</b> is only verified implicitly: If Bob willingly encrypts a message using both <b>b</b> and <b>y</b>, the latter must have been generated by him, as intended.)
 
<p> In E3DH, the <b>y</b> (or rather, its public version) is simply verified directly via the DSA: I won't describe the true mathematics but it relies on asymmetric cryptography, where encryption is easy but decryption is hard. Hypothetically it would go like this: Bob would "decrypt" <b>y</b>, and publish the "plaintext." Alice (or anyone) can "encrypt" this plaintext to get <b>y</b> back. Since decryption is hard (feasible only for Bob), this confirms Bob witnessed <b>y</b> and accepted it (in this case, as his own key).
 
 <p>That's it for Diffie-Hellman. Next, I may indeed talk about more primitive primitives: The DSA in more depth perhaps, or elliptic curves.
