---
layout: post
title: "The ChatScrypt Architecture Part VI: The Treasure Hunt Protocol"
comments: true
date: 2020-02-08
---

Not surprisingly, I've discovered the postal DH protocol has some flaws. First, when Alice sends Bob a message, instigating him to push his "half message" consisting of his next key to the server, and Alice later fetches it to send her next message, the server can link the "two instances of Alice," and thus all instances of Alice. Second, the protocol is in fact fundamentally incomplete. When Alice asks the server for the key to send Bob a message, the server can't reply with the right key unless it knows something about Alice's identity.

<p>So I have more tricks. The difficulty with trying to preserve not just confidentiality but anonymity is that messages should be instant, but from time-coincident messages, the server can deduce a coherent identity for Alice. One way to work with this is to be as efficient with each set of time-coincident messages as posssible: to frontload all the instructions, so to speak, so that the next time Alice contacts Bob, she can choose an esoteric identifier, preserving the separation between every two instances of Alice. This is like a postal model, but in the style of some sort of spy film: a postal model where Alice and Bob repeatedly direct the other to "secret" public lockers.

<h2>Diffie-Hellman keys with address</h2>

I will use an expanded notion of DH key pair in the following. A typical DH key pair has a private key and a public key. To this I will append an address. I will abuse notation and refer to them all with the same letter: Private key <b>x</b>, public key <b>x</b>, and key address <b>x</b>. The notion of the address is mostly for psychological clarity. A straightforward implementation would be to set the address to a hash of the public key.

<p>When I refer to a key as Alice's, this means that the private key is known only to Alice. So when Alice has Bob's key, it means she has his public key with its address. In fact, in the following I will define the address to be a double hash of the public key, so that I have access to a single hash, "address precursor."
  
<h2>Storing messages on the server</h2>

Up until now, I have refrained from mentioning my plans for how to handle message storage, mostly because I thought there wasn't much to it. I had been intending to make this an option for the user: storing messages locally, vs. on the cloud. Viewing the server like a cloud storage service, implementing local storage would simply be like downloading one's data. I was intending to implement cloud storage first, simply because I have the database code mostly figured out, and I don't like browser-based user storage for its lack of usabiility.

<p>It's very clear that all this business regarding forward/future secrecy is entirely and inevitably destroyed by using cloud storage: A single password or encryption key would crack all of one's messages. My objectives with improving the Signal protocol were thus very clearly defined, as academic.
  
<p>But now that I've accidentally entered the matter of anonymity, things are a bit more subtle. It's no longer entirely clear that that anonymity is destroyed by enrolling in cloud storage. So let me give this a shot below. In particular, it will be important to specify what data is on the server, vs what data is local. 
  
<h2>Alice's state</h2>

After the protocol has initiated, Alice has the following (ephemeral) state when she is logged in:

<ul>
<li>Alice's key <b>x</b>, and pending key <b>x*</b>.
<li>Bob's key <b>y</b>, and previous key <b>y'</b>.
</ul>

<p>Bob has the same state in reverse. 

<h2>The server's state</h2>

The server has the following state:

<ul>
  <li>Alice's recent sending key <b>a</b>.
  <li>Bob's offline receiving backup key <b>b</b>.
</ul>





<h2>Initialization</h2>

Bob publishes to the server a public key <b>b</b>. He refreshes this key every time he comes online, and while online, every time someone new initiates a stream of messages to him. 

<p>When Alice wants to initiate a stream of messages to Bob, she fetches Bob's public key and initializes her state:
<ul>
<li>Alice sets <b>x, x*</b> to the same new DH key.
<li>Both of Bob's keys are set to <b>y</b>. 
</ul>

<p>Bob initializes in the same way, in reverse. If he is online, this is straightforward. If not, note that the initialization can all be completed by the server and Alice. The private key <b>y</b> needs to be delayed until Bob comes online, but Alice doesn't need it to get started.
  


<h2>Sending a message</h2>

Alice decrypts <b>y*</b> using <b>y, x*</b> and updates keys:
<ul>
<li>She updates private <b>x = x*</b> and saves a new DH key pair to <b>x*</b>, checking to ensure it is distinct.
  <li>She updates public <b>y' = y</b> and then <b>y = y*</b>.
</ul>
Finally, she sends her message, encrypted with the shared encryption key <b>g^(xy) mod N</b>, including the public key <b>x*</b> in the encrypted message. 

<p>If the binary is true, she does the same but without checking or updating keys.

<p>If the <b>y*</b> is old however, she creates a new DH key pair with private key <b>r</b> and then encrypts her message using the shared encryption key <b>g^(ry) mod N</b>. As before, she includes the public key <b>x*</b> in the encrypted message. However, now she attaches the public key <b>r</b> encrypted with key <b>g^(xy) mod N</b>. Once sent, she immediately deletes <b>r</b>.
