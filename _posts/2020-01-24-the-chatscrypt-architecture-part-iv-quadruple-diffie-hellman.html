---
layout: post
title: "The ChatScrypt Architecture Part IV: Quadruple Diffie-Hellman"
comments: true
date: 2020-01-24
---

I decided to carefully write out my third and hopefully final attempt at the protocol I will be using for ChatScrypt, a version of the AIDH protocol with four keys. I've settled on the name Quadruple Diffie-Hellman (QDH). This will be slightly different from how I ended the previous post, in that Alice will ask for permission to update her own keys, not Bob's. This is more efficient and deterministic, since Alice is the one controlling her own key generation.

<p>I will omit writing literal public keys <b>g^x mod N</b>, writing just "public key <b>x</b>" instead.


<h2>Alice's state</h2>

<p>Once the protocol is initiated, Alice will have the following state variables:
<ul>
<li>The number of messages <b>M</b> she has sent, and a list of integers enumerating which of Bob's messages she has received. (The contiguous part stemming from 0 may be deleted.) The list should typically be length 1.
<li>Alice's current private key <b>x</b> and pending private key <b>x*</b>, waiting for confirmation from Bob.
<li>Bob's current public key <b>y</b> and previous public key <b>y'</b>, in case Alice has processed the update to <b>y</b>, but Bob is unaware and still sending <b>y'</b> encrypted messages.
<li>A binary that is either Active or Passive. If Active, this indicates that Alice's next message with have two effects: initiating a new key update request, and notifying Bob that his update request has been processed. Both will instigate updates in Bob's keys.
</ul>



<h2>Initialization</h2>
Bob publishes to the server a new signed public key <b>y</b>. He refreshes this key every time someone initiates a new correspondence with him. Alice publishes to the server an unsigned but long-term public key <b>a</b>.

<p>When Alice wants to initiate a correspondence with Bob, she fetches Bob's signed public key, verifies the signature, and sends some metadata to Bob using the shared Diffie-Hellman encryption key
<div class="media">
<b>g^(ay) mod N.</b>
</div>

Alice then initializes her state:
<ul>
<li>The number of messages <b>M</b> is set to 0, and an empty list of integers is initialized.
<li>Both private keys are set to <b>a</b>.
<li>Both of Bob's public keys are set to <b>y</b>. 
<li>Alice is Active.
</ul>

<p>Bob is similarly initialized, with private keys set to <b>y</b> and public keys set to <b>a</b>. Bob is Passive.



<h2>Sending a message</h2>
Alice creates a new Diffie-Hellman key pair with private key <b>r</b> and then encrypts her message using the shared Diffie-Hellman encryption keys 
<div class="media">
<b>g^(xy) mod N</b> and <b>g^(ry) mod N</b>.
</div>


She updates her state:
<ul>
<li>Increment <b>M = M + 1</b>. The integer list is unchanged.
<li>If Active, update private <b>x* = r</b>.
<li>Both of Bob's public keys are unchanged.
<li>Set to Passive.
</ul>


She delivers her message with the following attachments:
<ul>
<li> (unencrypted) The public key <b>r</b>. 
<li> (encrypted) The message number <b>M + 1</b>, and the number of messages Bob has sent Alice (0 if not contiguous).
  <li> (encrypted) The Active/Passive binary is included here, along with public key <b>x*</b>.
</ul>





<h2> Receiving a message</h2>

If Bob is Active, he decrypts the message using <b>x', y, r</b>. If he is Passive, he uses <b>x, y*, r</b> (but if Bob recently became passive and Alice hasn't found out yet, he may need to revert to the other set as backup). 

<p>If Bob is Passive and the message is Passive, someone's message was dropped. Bob can check his copy of Alice's public key against the included <b>x*</b>; if they do not match, he missed one of Alice's Active messages, and so pretends this is an Active message. If they do match, Bob is up to date so Alice is the one who did not receive one of his messages. At this point he can send her a Passive message and let her sort things out.
  
<p>There is some key deletion in the below; Bob needs to be sure it's safe to delete. Alice's Active message is a promise that she has processed Bob's key update request and will henceforth use his newer key. Further, it says she is ready to delete her current private key, but will keep using it until Bob replies to her. However, there are no promised about older, out of order messages from Alice, so here Bob needs to wait for all older messages from Alice before proceeding. (They will be passive, however, so it is also an option to not wait and just drop those messages.)

<ul>
<li>Bob's <b>M</b> is unchanged. The integer list is updated. If the list is contiguous from the beginning, Bob can empty the list. 
<li>If the message binary is Active, update private <b>y = y*</b>.
<li>If the message binary is Active, update public <b>x' = x</b> (the right hand side is from Bob's state) and <b>x = x*</b> (the right hand side is from the message).
<li>If the message binary is Active, Bob's state binary becomes Active.
</ul>



<h2>Analysis</h2>

<p>As discussed, these two implementations are not better or worse than each other. They balance three things: 1. Authentication security (faster authentication key refresh), 2. Message security (faster key deletion), 3. Robustness against dropped messages. The previous implementation achieved 1 and 3, but was weak at 2, with potentially large numbers of keys stored. The implementation above achieves 2 and 3, but is slightly weaker at 1.
  
<p>There is possibility of a third implementation, which achieves 1 and 2 but is weak at 3. Here, the implementation would refuse to let Bob speak until he has read Alice's most recent message. I'm very tempted suddenly to go with this one...
