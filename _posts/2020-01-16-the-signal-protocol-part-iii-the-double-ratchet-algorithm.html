---
layout: post
title: "The Signal Protocol Part III: The Double Ratchet Algorithm"
comments: true
date: 2020-01-16
---

Change of plan once again: I'm going to discuss the <i>Double Ratchet Algorithm</i> (DRA), the second of two components constituting the Signal protocol (the first being the Extended Triple Diffie-Hellman I discussed in <a href="https://chatscrypt.github.io/2020/01/06/the-signal-protocol-part-ii-the-diffie-hellman-key-exchange">Part II</a>). Further, I won't go into detail as the full algorithm is fairly complicated, and I currently do not intend to use it. Instead, I will provide an overview, followed by some analysis.

<p>
<h2>Overview</h2>


Recall from the end of the discussion in Part II that there isn't an entirely satisfactory solution for asynchronous forward secrecy. E3DH loads a finite number of one-use keys in advance, but this is unsustainable in the worst case.

<p>An alternative strategy that comes very close to success is the following: Simply hash the shared secret key and use the output as the next shared secret key; repeat this for each message. (There can be some agreed-upon offline protocol tracking how many rounds of hashing have been performed for a particular key/message pair, thus preserving asynchronicity.) The hashing destroys access to past keys; ergo, forward secrecy. This idea is essentially termed a <i>Key Derivation Function (KDF) chain</i> in the DRA.

<p>However, this strategy loses <i>future secrecy</i>: the property that a shared secret key is eventually decomissioned <i>entirely</i>. (In practice, it is mixed with some random input so as to become essentially brand new.) A vanilla KDF chain fails this as it implicitly reuses old keys indefinitely: Once a key is stolen, the thief obtains future keys via the hash, just as Alice or Bob would. The Double Ratchet Algorithm is essentially an organized way to intermittently inject new random input into a KDF chain to preserve future secrecy. (This random data is securely shared between Alice and Bob via some Diffie-Hellman scheme.)

<h2>Analysis</h2>

<ul>
<li> The forward secrecy is more or less impeccable, assuming a secure hash/KDF. 

<li> As claimed multiple times, an entirely asynchronous future secrecy is impossible. The trouble with the DRA is that if Bob's private keys are compromised while Bob is offline for a long stretch of time, Alice has no way of communicating with Bob. She needs to wait for him to come online, and "inject" new keys. 

<li>As stated in the technical specification on the Signal website, the actual DRA is even worse than this: If Alice was the last person to send a message, the next "injection" of new keys is only performed when Bob explicitly sends a message to Alice. If Bob is online but doesn't explicitly reply for whatever reason, Alice is stuck using Bob's old, potentially compromised keys. Admittedly, this could be repaired under-the-hood by notifying Alice each time Bob receives one of her messages, and treating these notifications as implicit replies. To my knowledge, it is not specified whether Signal does this.

  
<li>I did not mention this before, but there is some protection against man-in-the-middle attacks built into the DRA. All new Diffie-Hellman keys are mixed with authenticated keys from an initial E3DH. 
  
<li>A much simpler protocol that avoids all these complications would be for Alice and Bob to each constantly maintain a Diffie-Hellman key, publish the public version, and update keys upon receipt or delivery of any message. My best guess as to why this was not used by Signal is that this would be slow (the signing of the public key for authentication).

</ul>
