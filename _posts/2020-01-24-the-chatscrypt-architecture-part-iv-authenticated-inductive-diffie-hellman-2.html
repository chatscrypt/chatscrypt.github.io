---
layout: post
title: "The ChatScrypt Architecture Part IV: Authenticated Inductive Diffie-Hellman 2.0"
comments: true
date: 2020-01-24
---

I decided to carefully write out my third and hopefully final attempt at the protocol I will be using for ChatScrypt, a version of the AIDH protocol with four keys. This will be slightly different from how I ended the previous post, in that Alice will ask for permission to update her own keys, not Bob's. This is more efficient and deterministic, since Alice is the one controlling her own key generation.

<p>I will omit writing literal public keys <b>g^x mod N</b>, writing just "public key <b>x</b>" instead. Note that this is the <i>entire</i> protocol, right here, merging Signal's E3DH and Double Ratchet, simplifying both internally, and strictly improving security, as far as I can tell. Of course, these statements need some peer review.


<h2>Alice's state</h2>

<p>Once the protocol is initiated, Alice will have the following state variables:
<ul>
<li>Alice's message counter <b>M</b>, and a list of integers enumerating which of Bob's messages she has received. (The contiguous part stemming from 0 may be deleted.) The list should typically be length 1.
<li>Alice's current private key <b>x</b>, and pending private key <b>x*</b> waiting for confirmation from Bob.
<li>Bob's current public key <b>y</b>, and previous public key <b>y'</b> in case Alice has processed the update to <b>y</b>, but Bob is unaware and still sending <b>y'</b> encrypted messages.
<li>A binary that is either Active or Passive. If Active, Alice's next message with have two effects: initiating a new key update request, and notifying Bob that his update request has been processed. Both will instigate updates in Bob's keys.
</ul>



<h2>Initialization</h2>
Alice publishes to the server an unsigned but long-term public key <b>a</b>. Bob publishes to the server a new signed public key <b>y</b>. He refreshes this key every time someone initiates a new correspondence with him (if he is online; otherwise this key is reused).

<p>When Alice wants to initiate a correspondence with Bob, she fetches Bob's signed public key, verifies the signature, and initializes her state:
<ul>
<li>Message counter <b>M</b> is set to 0, and an empty list of integers is initialized.
<li>Alice sets <b>x = a</b> and saves a new Diffie-Hellman key pair to <b>x*</b>. Ensure that the new key is different from the old one (astronomically unlikely, but still).
<li>Both of Bob's public keys are set to <b>y</b>. 
</ul>

<p>Bob is, with both private keys set to <b>y</b> and public keys set to <b>a</b>.



<h2>Sending a message</h2>
Alice creates a new Diffie-Hellman key pair with private key <b>r</b> and then encrypts her message using the shared Diffie-Hellman encryption keys 
<div class="media">
<b>g^(xy) mod N</b> and <b>g^(ry) mod N</b>.
</div>

She delivers her message with the following attachments:
<ul>
<li> (unencrypted) The public keys <b>r</b> and <b>x*</b>. 
<li> (encrypted) The message number <b>M + 1</b>.
<li> (encrypted) Alice's current Active/Passive binary.
</ul>

She updates her state by incrementing <b>M = M + 1</b> and setting her status to Passive.




<h2>Receiving a message</h2>

If the incoming <b>x*</b> doesn't match <b>x</b>, Bob decrypts using <b>x, y*, r</b> and updates keys:
<ul>
<li>Update private <b>y = y*</b> and save a new Diffie-Hellman key pair to <b>y*</b>. Ensure that the new key is different from the old one (astronomically unlikely, but still).
<li>Update public <b>x' = x</b> and then <b>x = x*</b>.
</ul>
If the incoming <b>x* = x</b>, Bob decrypts the message using <b>x', y, r</b>. In all cases, the integer list is updated. If the list is contiguous from the beginning, Bob can empty the list up to one element. 


<h2>Dropped messages</h2>

Dropped messages are handled on the receiving side:
  
<p>There is some key deletion in the receiving phase; Bob needs to be sure it's safe to delete. Alice's Active message is a promise that she has processed Bob's key update request and will henceforth use his newer key. Further, it says she is ready to delete her current private key, but will keep using it until Bob replies to her. However, there are no promises about older, out of order messages from Alice, so here Bob needs to wait for all older messages from Alice before proceeding. (They will be passive, however, so it is also an option to not wait and just drop those messages. Another possibility would be to organize a separate storage of keys for this scenario, which is only populated in the pathological situation of unordered messages.)

<p>If Bob is Passive, up to date, and the received message is still Passive, someone's message was dropped or out of order. Bob can check his copy of Alice's public key against the included <b>x*</b>; if they do not match, he missed one of Alice's Active messages, and so pretends this is an Active message. If they do match, Bob is up to date so Alice is the one who did not receive one of his messages. At this point he can send her a Passive message and let her sort things out.

<h2>Analysis</h2>

<p>As discussed, these two implementations of AIDH are not better or worse than each other. They balance three things: 1. Authentication security (faster authentication key refresh), 2. message security (faster key deletion), and 3. robustness against dropped/misordered messages. AIDH 1.0 achieved 1 and 3, but was weak at 2, with potentially large numbers of keys stored. AIDH 2.0 achieves 2 and 3, but is slightly weaker at 1.
  
<p>There might be the possibility of a third implementation, which achieves 1 and 2 but is weak at 3. Here, the implementation would refuse to let Bob speak until he has read Alice's most recent message. This isn't great, as it's hard to prevent the very real case where Alice and Bob talk over each other. Then they both update their keys, and a fraction of a second later, they both receive messages they can't decrypt. Neither can authenticate the other, though in principle they can still communicate using the attached public keys in the messages.
  
<p>Edit (1/24/2020): Let me clarify the weakness of this current implementation. 
  
<p>The issue is that when Alice sends an active message, she has fixed for the time being the next key that Bob will use to authenticate her. An attacker wanting to masquerade as Alice would know this, and get to work cracking this key. For as long as Bob does not reply to her, this key is valuable, opening the way to a man-in-the-middle attack. Alice has no way to repair this; sending passive messages does not update her authentication key. 
  
<p>Note that in contrast, messages in AIDH 1.0 are never passive: If Alice is worried that someone is trying to crack one of her keys, or has stolen it, she can rectify this without input from Bob: She can simply secure her computer and then send another message. If Bob sees it, the candidate authentication key is refreshed and the old key under attack is essentially discarded. However, recall that the weakness with AIDH 1.0 was that key storage requirements are unbounded.
  
<p>I should point out that the Signal protocol suffers from both these weaknesses: Unbounded key storage as well as "delayed authentication key regeneration." It does have "perfect" robustness against dropped and misordered messages, but this last bit is somewhat of a wasted effort, because permitting dropped messages isn't really a desirable feature. I suppose with Signal, it might be, due to the intent to have "infinite scroll." But for ChatScrypt, it's very much optional.

<p>Edit (1/24/2020): Nevermind, AIDH 2.0 is better than AIDH 1.0 in the authentication regard as well. It's key deletion that matters, not key creation. By keeping a large list of keys in AIDH 1.0, Alice is allowing any one of them to "represent her"; an attacker needn't use the newest one, as I mistakenly thought above. The only advantage comes in the fact that Alice can choose to use Bob's newest key to encrypt. 

<p>So is there any reason to use AIDH 1.0? Kind of; in 2.0, Alice is forced to use Bob's "oldest" and least secure encryption key. But in a way, message security is not a concern with these ratcheting forward/future secret protocols: This is the whole point. The biggest risk is a man-in-the-middle attack. And in that sense, it seems that 2.0 is just marginally better (as discussed, there are strictly fewer keys which authenticate Alice at any time). So it looks like this ends the discussion on the AIDH protocol! Next, Part V, I'll discuss ambient security considerations, including primitives and key storage.
