---
layout: post
title: "The ChatScrypt Architecture Part II: Repeated Double Diffie-Hellman"
comments: true
date: 2020-01-21
---

As I hinted at in my discussion of the Signal protocol, there are two things I did not like:

<ul>
<li> The one-time key idea used in the E3DH. This is too gimmicky for me.

<li> The Double Ratchet seems unnecessarily complicated, insisting on a KDF chain when a single Diffie-Hellman (DH) sequence would suffice, and in fact improve future secrecy.
</ul>

<p> My idea is to simplify the scheme into a Repeated Double Diffie-Hellman (R2DH) scheme, as follows:

<h2> Initializing the Double Diffie-Hellman</h2>

This would be similar to the E3DH, with the following differences:

<ul>
  
 <li>No optional one-time keys. Instead, Bob's posted short-term public key will refresh every time a new chat is initiated with him, if he is logged in.
   
 <li>Assuming Alice is messaging Bob, her encryption key will be (see <a href="https://chatscrypt.github.io/2020/01/06/the-signal-protocol-part-ii-the-diffie-hellman-key-exchange">Part II</a> of my discussion on the Signal protocol for notation)
<div class="media">
 <b>g^(ay) mod N</b> and <b>g^(xy) mod N</b>
</div>
   
 </ul>

<p> A remark: Signal appears to be contact-based, with infinite scroll, so initialization rarely happens. For ChatScrypt, the initialization procedure would repeat for each new chat.

<h2> Repeated Double Diffie-Hellman </h2>

Alice will encrypt each of her successive messages with a new random short-term DH key <b>x</b>, concatenated in the above sense with her long-term key. She will attach the following to her message:

<ul>
  <li> The corresponding public key for <b>x</b> so Bob can use it for decryption. 
   <li> She will also include which of Bob's public keys she used. As Bob will have provided her multiple short-term public keys <b>g^y mod N</b>, she will use the most recent one. As a result, Alice needs to store at most one of Bob's public keys at any time. 
<li>In her (encrypted) message, she also includes an integer specifying the number of this particular message, in the list of messages she has sent. This serves the two-fold purpose of being information, as well as a recognizably non-random string in the decrypted message (the latter is useful for authentication).
  </ul>

<p>When Bob receives a message from Alice, there is no ambiguity as to which of his private keys he should use to decrypt it. After decrypting it, he sees the number of the message, and can determine if he is up to date with all of Alice's messages so far. If so, he can delete all but his most recent DH key pair.
  
 <p>If Bob sends a lot of messages before Alice replies, this is a lot of key pairs to store. However, assuming no lost messages or delays, Bob really needs only to store his most recent key pair. As a result, it is reasonable for Bob to store at most, say 16 key pairs.
   
<p> Regarding authentication, and protection against man-in-the-middle attacks: Recall that the initial DH requires Bob's posted short term public key to have an attached signature for asynchronous authentication. In contrast, Alice's short-term public key is verified as it is concatenated in the above sense with her authenticated long-term key (and the resulting shared key is tested by decrypting the message number). Similarly, all future keys are deniably authenticated by concatenation with authenticated long-term keys; no signatures needed.


<h2>Analysis</h2>

I am worried about this protocol because - to entirely put aside any humility - it is too good. It is vastly simpler than Signal's Double Ratchet Algorithm, and seems to be strictly more secure. It has identical deniability properties, as no signatures are used except at the outset, just as in the Signal protocol. Combined with the "Postal Delivery Model" of Part I, the ChatScrypt server can only possibly collect data about how much mail each user receives, with timestamps. It can know nothing about whom is talking to whom, or even when a new contact is initiated.

<p>Let me list the relative weaknesses I can think of right now:
<ul>
  <li>Elephant in the room: Why double instead of triple? This would obviously cut overhead by a third. But is it as secure? Recall that two of three DH shared keys are used mostly for authentication. As shared keys are never used more than once in this protocol, there is only a need for one authenticating shared key. There is some lost security in that for instance, stealing Bob's <b>y</b> alone would crack the example shared key above; in the triple version, <b>x</b> or <b>b</b> would need to be stolen as well. However, chances are, if <b>y</b> is stolen, <b>b</b> is as well. 
    
<li> Of course, at initialization, I only have one short-term key, as opposed to multiple for E3DH. This compromises security in the very mild sense that if multiple people initiate chats with Bob while he is offline, they will all use the same public keys to build their shared DH encryption keys with Bob. They of course will use different private keys however, and so forward/future secrecy is preserved aside from the case of catastrophic RNG failure on Alice's side. (This is why multiple short-term keys was optional in E3DH to begin with.)

<li>I suspect KDF chains are faster than DH. But DH is pretty quick already, and as I pointed out last time, the Double Ratchet Algorithm actually should prefer that the DH-less KDF not run too long, as this damages future secrecy.
</ul>


On the other hand, there are some relative strengths:
<ul>
<li> Bob updates his posted short-term key more regularly.

<li> As already pointed out, for brief spurts in the Double Ratchet Algorithm, the KDF chains did not have satisfactory future secrecy. In fact, there is in principle an unbounded period of time with no future secrecy, if Bob refuses to reply to Alice. With R3DH however, there is at least a weak future secrecy established on Alice's side due to the use of a fresh private key for every single message.
  
<li>Minor, but here we easily keep the message number encrypted. The Signal protocol has a fairly complicated (though more secure) header encryption scheme that to my mind is mostly unnecessary.
</ul>
