---
layout: post
title: "Zero Knowledge Security: ChatScrypt Passwords"
comments: true
date: 2019-12-25
---

Or: Why you can (as of about December 23, 2019) feel free to use a real password when creating a ChatScrypt account (though there's nothing there right now once you do).

<p>Normally, when creating accounts with sketchy, unvalidated websites, you should offer a "fake" password, because chances are the web developers for that site are not securely storing the password you provide (not that you should be reusing passwords to begin with, but I assume you are only human).
  
 <p>The internet has a lot on the matter of password storage (google "store password database" or watch <a href="https://www.youtube.com/watch?v=8ZtInClXe1Q">this Computerphile video</a>, which is actually where I first learned about this business). Everyone who takes the time to write an article about this seems to make a big deal of it, as though it is extremely complicated, but I found that this is one of the simpler security matters out there (which perhaps is why it is a big deal: It's simple enough to allow average-to-mediocre software developers to handle on their own). I'll provide a quick overview:
   
<ul>
   <li> Passwords should always be "salted": Humans typically choose very poor passwords, and repeat them. Salting is where the software automatically appends random letters to the user-provided password to ensure the actual under-the-hood password is a "good" one. This protects against dictionary attacks.
     
   <li> Then, the salted password should be hashed, or essentially, encrypted while throwing away the key (more precisely, there never was a key). This is alright because the software doesn't actually need the password; it just needs to know whether someone knows the password. The deterministic nature of the destruction allows the software to check whether someone knows the password, by hashing a later claimed password and comparing with the original output. In any case: Only the hashed password should be stored in the database. This obviously protects users who reuse passwords in the case of a database breach, as password hashes are not readable.
</ul>

<h2>Server side or client side?</h2>

I did a lot of reading about password storage, and the above is all good and fine, but there was one particularly heated topic of debate on the internet: Whether the above process should be performed by the client (on your laptop/phone, or more precisely, your browser) or the server (in a cloud somewhere). 

<p> The consensus seems to be that this must be done on the server side. There is a good reason for this: If the database is compromised, the hashed password is useless. Envision the authentication process: The server authentication software accepts the <i>actual</i> password, and <i>then</i> salts and hashes it. A thief knowing only the hashed password cannot replicate this process.

<p>In contrast, if all the clever stuff above is done client-side, then the true user is indistinguishable from the thief: both present only a hashed password to the server.
  
<p>Strangely, the internet seems to downplay the fact that the client has no way of knowing whether the server is performing the standard salt-hash safeguards (or even whether the server's developers are themselves trustworthy, which is evidently the case here). A client-side salt-hash guarantees a client-verifiable minimal level of protection, which is not even that bad. In the worst case, a user's ChatScrypt account may be compromised, but his/her other accounts are safe, even if they share passwords.
  
<p>I'm pleased to claim that ChatScrypt currently does <i>both</i>, client-side and server-side salting and hashing. I cannot prove this of the server, short of publicizing my Github/Heroku passwords, but you can actually check the client-side code (in Firefox, right click and view the source code). In particular, you can see that the plaintext password is salted and hashed via <a href="https://en.wikipedia.org/wiki/Bcrypt">bcrypt</a> and so I (the server) never see the users' plaintext passwords.
  
  <p>This is an instance of <i>zero-knowledge security</i> - the user's data cannot be compromised, because the software never receives it (in a readable form) to begin with.
