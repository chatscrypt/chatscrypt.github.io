---
layout: post
title: "The ChatScrypt Architecture Part VI: The Treasure Hunt Protocol"
comments: true
date: 2020-02-08
---

New issues: I realize the postal DH protocol is flawed. When Alice sends Bob a message, instigating him to push his "half message" containing his next key to the server, and Alice later fetches it, the server can link the "two instances of Alice" and thus all instances of Alice, in principle. In fact, the protocol is fundamentally incomplete: When Alice asks the server for the key to send Bob a message, the server can't reply with the right key unless it knows Alice's identity.

<p>So I have more tricks. The difficulty with trying to preserve not just confidentiality but anonymity is that messages should be instant, but from time-coincident messages, the server can deduce a coherent identity for Alice. One way around this could be a postal model where Alice and Bob repeatedly direct the other to "secret" public lockers, like a treasure hunt. 

<h2>Diffie-Hellman keys with ID</h2>

I will use an expanded notion of DH key pair in the following. A typical DH key pair has a private key and a public key. To this I will append an address. I will abuse notation and refer to them all with the same letter: Private key <b>x</b>, public key <b>x</b>, and key ID <b>x</b>. The notion of the address is mostly for psychological clarity. A straightforward ID implementation would be a hash of the public key.

<p>When I refer to a key as Alice's, this means that the private key is known only to Alice. So when Alice has Bob's key, it means she has his public key with its ID.
  
<h2>Alice's state</h2>

After the protocol has initiated, Alice has the following state:

<ul>
<li>Alice's key <b>x</b>, and pending key <b>x*</b>.
<li>Bob's key <b>y</b>, and previous key <b>y'</b>.
</ul>


<h2>Initialization</h2>

Bob publishes to the server a public key <b>y</b>. He refreshes this key every time he comes online, and while online, every time someone new initiates a stream of messages to him. 

<p>When Alice wants to initiate a stream of messages to Bob, she fetches Bob's public key and initializes her state:
<ul>
<li>Alice sets <b>x, x*</b> to the same new DH key.
<li>Both of Bob's keys are set to <b>y</b>. 
</ul>

<p>Bob initializes in the same way, in reverse. If he is online, this is straightforward. If not, note that the initialization can all be completed by the server and Alice. The private key <b>y</b> needs to be delayed until Bob comes online, but Alice doesn't need it to get started.
  
<h2>Sending a message</h2>

Alice decrypts <b>y*</b> using <b>y, x*</b> and updates keys:
<ul>
<li>She updates private <b>x = x*</b> and saves a new DH key pair to <b>x*</b>, checking to ensure it is distinct.
  <li>She updates public <b>y' = y</b> and then <b>y = y*</b>.
</ul>
Finally, she sends her message, encrypted with the shared encryption key <b>g^(xy) mod N</b>, including the public key <b>x*</b> in the encrypted message. 

<p>If the binary is true, she does the same but without checking or updating keys.

<p>If the <b>y*</b> is old however, she creates a new DH key pair with private key <b>r</b> and then encrypts her message using the shared encryption key <b>g^(ry) mod N</b>. As before, she includes the public key <b>x*</b> in the encrypted message. However, now she attaches the public key <b>r</b> encrypted with key <b>g^(xy) mod N</b>. Once sent, she immediately deletes <b>r</b>.
