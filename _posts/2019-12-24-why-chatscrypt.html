---
layout: post
title: "Why ChatScrypt?"
comments: true
date: 2019-12-24
---

My first inclination to begin the <a href="https://chatscrypt.herokuapp.com/">ChatScrypt</a> project germinated in response to the decline of Gchat as it moved away from a session-based, searchable, reviewable message history, as well from a compact, simple chat interface, in favor of the infinite-scroll, always-on, space-inefficient implementation via Hangouts. This alone wasn't enough to prod me into doing anything about it, but then in early 2019, Google announced the eventual retirement of Hangouts itself.

<p>In response, I thought it would be educational to try to code a simple chat client, with the specific features that I wanted. My background includes some basic algorithms and theoretical computer science, as well as about a year of actual "coding" courses - the typical training that gives the young student confidence enough to code anything, at least within the confines of one machine. Accordingly, to my mind, as soon as I figured out how to transmit morse code or an equivalent over a network - the educational bit to this project - the rest would be like filling in a coloring book.
  
<p>I wasn't entirely wrong, but it turns out the project would be more fun than I anticipated, due to the following complications:
  
<ul>
  
<li> I realized that for this program to be useful for communication in which one endpoint isn't me, I would need to ensure that I could not read the messages in my database - messages between my friend and his wife, for instance. I looked for a standard protocol to shield messages from the mediating software developers, but to my surprise, there was no such protocol. In principle, any Google engineer can read any user's messages and emails (and presumably the messages of their Gmail-using friends, incidentally). So-called "end-to-end encryption" was relegated to the preferred software of only the famously paranoid (Snowden seems to be a common name in this business).

<li> In recent years, end-to-end encryption has become more popular (Whatsapp, Telegram, Signal) but typically is tied to poor message history and reviewability for the user. This is understandable, as encrypted data is inherently unsearchable. It seems that the challenge is to find an appropriate balance between security and usability.

  
<li> Web-based programming isn't fundamentally harder than standalone programming, but the lack of standards makes the process collaborative on one hand, and a great mess on the other. Choosing a language, setting up an environment - all of this is non-canonical. Tutorial-based osmotic learning seems to be the norm.
  
<li> There are all sorts of features I hadn't considered before, whose implementation require conscious design choices. These include session handling, login recovery, offline messages, group messaging, etc. These design choices often merit some discussion.
  
</ul>
  
All of this was complex enough to start a blog to accompany the development of what I decided to call ChatScrypt: Chat + encryption + tranScription, highlighting the two main features I want in the final product. My goal is to discuss design choices that arise in response to security and usability concerns (and vice versa). I think this might be interesting, irrespective of ChatScrypt itself. For instance, as I pointed out above, I, and presumably most people, started using Gmail without a thought as to the multitude of security risks this entailed. Yet I found out in the course of researching gchat security that it was only by about 2014 that <a href="https://gizmodo.com/every-single-gmail-message-you-send-will-now-be-encrypt-1548130115">Google normalized the encryption of Gmail transmissions</a>!
