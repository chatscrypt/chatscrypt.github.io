---
layout: post
title: "The Origins of ChatScrypt"
comments: true
date: 2019-12-24
---

My first inclinations to begin the <a href="https://chatscrypt.herokuapp.com/">ChatScrypt</a> project germinated in response to the decline (in the opinion of this developer) of gchat, as it moved away from a session-based, searchable, reviewable message history, as well from a compact, simple chat interface, in favor of the infinite-scroll, always-on, space-inefficient implementation via Hangouts. This alone wasn't enough to prod me into doing anything about it, but then in early 2019, Google announced the eventual retirement of Hangouts itself.

<p>In response, I thought it would be educational to try to code a simple chat client, with the specific features that I wanted. My background includes some basic algorithms and theoretical computer science, as well as coding in C and Java - the type of training that gives the student confidence that he/she can code anything, at least within the confines of one machine. Accordingly, to my mind, as soon as I figured out how to transmit morse code or an equivalent via the internet - the educational bit - the rest would be like filling in a coloring book.
  
<p>I wasn't entirely wrong, but it turns out the project would be more fun than I anticipated, due to the following complications:
  
<ul>
  
<li> I realized that for this program to be useful for communication in which one endpoint isn't me, I would need to ensure that I could not read the messages in my database - messages between my friend and his wife, for instance. I looked for a standard protocol to shade messages from the mediating software developers, but to my surprise, there was no such protocol. In principle, any Google engineer can read my messages and emails (and presumably the messages of their gmail-using friends, incidentally). So-called "end-to-end encryption" was relegated to the preferred software of only the famously paranoid (Snowden seems to be a common name in this business).

<li> In recent years, end-to-end encryption has become more popular (Whatsapp, Telegram, Signal) but typically is tied to poor message history and reviewability for the user. This is understandable, as encrypted data is inherently unsearchable. It seems that the challenge is to find an appropriate balance between security and usability.

  
<li> Web-based programming isn't fundamentally harder than standalone programming, but the lack of standards makes the process collaborative on one hand, and a great mess on the other. There is great opportunity for paralysis by analysis. Choosing a language, setting up an environment - all of this is non-canonical. Tutorial-based osmotic learning seems to be the norm.
  
<li> There are all sorts of features whose implementation require design choices I hadn't considered before, like session handling, login recovery, offline messages, group messaging, etc.
  
</ul>
  
All of this was complex enough to start a blog to accompany the development of what I decided to call ChatScrypt: Chat + encryption + tranScription, highlighting the two main features I want in the final product. My goal is to discuss design choices that arise in response to security and usability concerns (and vice versa). I think this might be interesting: As I pointed out above, I, and presumably most people, started using Gmail without a thought to the multitude of security risks this entailed. For instance, I found out that it was only by about 2014 that <a href="https://gizmodo.com/every-single-gmail-message-you-send-will-now-be-encrypt-1548130115">Google standardized encryption of Gmail transmissions</a>!
